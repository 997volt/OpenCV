#include <opencv2/opencv.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include <stdio.h>
#include <iostream>
#include <chrono>
#include <ctime>

#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"

#pragma region doWszystkich

cv::Mat image, Px, Py, Sx, Sy;

static void on_trackbar(int, void*)
{

}

static void onMouse(int event, int x, int y, int, void*)
{
	if (event == 4)
	{
		std::cout << std::endl << "lewy" << std::endl;
		cv::rectangle(image, cv::Point(x - 20, y - 20), cv::Point(x + 20, y + 20), cv::Scalar(120, 0, 155), 5);
	}

	if (event == 5)
	{
		std::cout << std::endl << "prawy" << std::endl;
		cv::circle(image, cv::Point(x, y), 25, cv::Scalar(25, 140, 60), 5);
	}

	cv::imshow("window", image);
}

void OLDdoNegativeWithRandomAccess(cv::Mat &img) {
	int rows = img.rows;
	int cols = img.cols;

	for (int i = 0; i < rows; ++i) {
		for (int j = 0; j < cols; ++j) {
			img.at<uchar>(i, j) = 255 - img.at<uchar>(i, j);
		}
	}
}

void OLDdoNegativeWithForEach(cv::Mat &img) {
	img.forEach<unsigned char>([](unsigned char &p, const int *position) {
		p = 255 - p;
	});
}

void doNegativeWithRandomAccess(cv::Mat &img) {
	using Pixel = cv::Vec<uchar, 3>;

	int rows = img.rows;
	int cols = img.cols;

	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < cols; j++) {
			img.at<Pixel>(i, j).val[0] = 255 - img.at<Pixel>(i, j).val[0];
			img.at<Pixel>(i, j).val[1] = 255 - img.at<Pixel>(i, j).val[1];
			img.at<Pixel>(i, j).val[2] = 255 - img.at<Pixel>(i, j).val[2];
		}
	}
}

void doNegativeWithMatIterator(cv::Mat &img) {
	using Pixel = cv::Vec<uchar, 3>;

	for (Pixel &p : cv::Mat_<Pixel>(img)) {
		p.val[0] = 255 - p.val[0];
		p.val[1] = 255 - p.val[1];
		p.val[2] = 255 - p.val[2];
	}
}

void doNegativeWithLambda(cv::Mat &img) {
	using Pixel = cv::Vec<uchar, 3>;

	img.forEach<Pixel>([](Pixel &p, const int * position) -> void {
		p.val[0] = 255 - p.val[0];
		p.val[1] = 255 - p.val[1];
		p.val[2] = 255 - p.val[2];
	});
}


#pragma endregion

#pragma region lab1
//live video capture with blur slider
int lab1zad1() {

	cv::Mat frame, blurred_frame;

	const int blur_slider_max = 100;
	int blur_slider = 0;

	cv::VideoCapture cap(0); // open the default camera
	if (!cap.isOpened()) // check if we succeeded
		return -1;

	cv::namedWindow("image");
	cv::createTrackbar("trackbar", "image", &blur_slider, blur_slider_max, on_trackbar);
	on_trackbar(blur_slider, 0);

	for (;;) {

		cap >> frame; // get a new frame from camera
		if (blur_slider > 0)
			cv::blur(frame, frame, cv::Size(blur_slider, blur_slider));

		cv::imshow("image", frame);
		if (cv::waitKey(30) >= 0) break;
	}
}

#pragma endregion

#pragma region lab2

//operacje na macierzach
void lab2zad1()
{
	cv::Mat matrix;

	std::cout << std::endl << "Single channel matrix:" << std::endl;
	matrix.create(4, 4, CV_8UC1);
	std::cout << "matrix.create(4, 4, CV_8UC1);" << std::endl << matrix << std::endl;
	matrix.setTo(cv::Scalar(128));
	std::cout << "matrix.setTo(Scalar(128));" << std::endl << matrix << std::endl;

	std::cout << std::endl << "Multi-channel matrix:" << std::endl;
	matrix.create(2, 2, CV_8UC3);
	std::cout << "matrix.create(2, 2, CV_8UC3);" << std::endl << matrix << std::endl;
	matrix.setTo(cv::Scalar(1, 2, 3, 4));
	std::cout << "matrix.setTo(Scalar(1, 2, 3, 4));" << std::endl << matrix << std::endl;

	std::cout << std::endl << "Matlab style:" << std::endl;
	matrix = cv::Mat::eye(5, 5, CV_64FC1);
	std::cout << "matrix = Mat::eye(5, 5, CV_64FC1);" << std::endl << matrix << std::endl;

	std::cout << std::endl;
	matrix = cv::Mat_<double>({ 3, 3 }, { 11, 12, 13, 21, 22, 23, 31, 32, 33 });
	std::cout << "Cała macierz:" << std::endl << matrix << std::endl;
	std::cout << "Wyświetlanie tylko fragmentu macierzy:" << std::endl;
	std::cout << "Pierwszy wiersz: matrix.row(0):" << std::endl << matrix.row(0) << std::endl;
	std::cout << "Ostatnia kolumna: matrix.col(matrix.cols-1):" << std::endl << matrix.col(matrix.cols - 1) << std::endl;

	std::cout << std::endl;
}

//tworzenie konkretnej macierzy
void lab2zad2()
{
	cv::Mat matrix;

	matrix.create(cv::Size(3, 3), CV_8UC1);

	for (int i = 0; i < 3; i++)
	{
		matrix.row(i).setTo(cv::Scalar(i + 1));
	}

	std::cout << matrix << std::endl;
}

//macierze - przykład jak lepiej nie robić
void lab2zad3_przyklad()
{
	cv::Mat mat1, mat2;
	mat1.create(cv::Size(5, 5), CV_8UC1);
	cv::randu(mat1, cv::Scalar::all(0), cv::Scalar::all(10));
	cv::Mat mat3(mat1, cv::Rect(2, 2, 2, 2));
	mat2 = mat1;
	std::cout << mat1 << std::endl << mat2 << std::endl << mat3 << std::endl;
	mat2.setTo(6);
	std::cout << mat1 << std::endl << mat2 << std::endl << mat3 << std::endl;
}

//kopiowanie macierzy (lub ich fragmentów)
void lab2zad3()
{
	cv::Mat mat1, mat2, mat3;
	mat1.create(cv::Size(5, 5), CV_8UC1);
	cv::randu(mat1, cv::Scalar::all(0), cv::Scalar::all(10));
	std::cout << "Orginal matrix:" << std::endl << mat1 << std::endl << std::endl;


	mat2 = mat1.row(0).clone();
	mat1.col(1).copyTo(mat3);
	mat1.setTo(0);
	std::cout << "Matrix changed to zeros:" << std::endl << mat1 << std::endl << std::endl;
	std::cout << "1st row of orginal matrix:" << std::endl << mat2 << std::endl << std::endl;
	std::cout << "2nd column of orginal matrix:" << std::endl << mat3 << std::endl << std::endl;
}

//negatyw
void lab2zad4()
{
	cv::Mat image;
	image = cv::imread("pies.jpg", CV_LOAD_IMAGE_GRAYSCALE);

	auto start = std::chrono::system_clock::now();
	for (int i = 0; i < 10; i++)
	{
		doNegativeWithRandomAccess(image);
	}
	auto end = std::chrono::system_clock::now();
	std::chrono::duration<double> elapsed_secondsRA = (end - start) * 1000;

	start = std::chrono::system_clock::now();
	for (int i = 0; i < 10; i++)
	{
		doNegativeWithForEach(image);
	}
	end = std::chrono::system_clock::now();
	std::chrono::duration<double> elapsed_secondsFE = (end - start) * 1000;

	std::cout << "Random access time (in miliseconds):" << std::endl << elapsed_secondsRA.count() << std::endl;
	std::cout << "For each time (in miliseconds):" << std::endl << elapsed_secondsFE.count() << std::endl;

	cv::namedWindow("Display window");// Create a window for display.
	cv::imshow("Display window", image);
	cv::waitKey(0);
}

//reading image, splitting and connecting
void lab2dom1()
{
	cv::Mat image = cv::imread("pies.jpg", CV_LOAD_IMAGE_COLOR);
	cv::Mat image_left = image.colRange(0, image.cols / 2);
	cv::Mat image_rigth = image.colRange(image.cols / 2, image.cols);
	cv::Mat hconcat, vconcat;

	cv::hconcat(image_rigth, image_left, hconcat);
	cv::vconcat(image_left, image_rigth, vconcat);

	cv::rectangle(hconcat, cv::Point(210, 20), cv::Point(350, 250), cv::Scalar(120, 0, 155), -1);

	cv::namedWindow("image");
	cv::imshow("image", hconcat);
	cv::waitKey(0);
}

void lab2dom2()
{
	cv::Mat image = cv::imread("pies.jpg", CV_LOAD_IMAGE_COLOR);
	cv::Mat image_left = image.colRange(0, image.cols / 2);
	cv::Mat image_rigth = image.colRange(image.cols / 2, image.cols);
	cv::Mat frame;

	cv::VideoCapture cap(0); // open the default camera	

	for (;;)
	{
		cap >> frame; // get a new frame from camera

		//merge images
		cv::hconcat(image_rigth, frame, frame);
		cv::hconcat(frame, image_rigth, frame);
		cv::rectangle(frame, cv::Point(210, 20), cv::Point(350, 250), cv::Scalar(120, 0, 155), -1);

		cv::imshow("image", frame);
		if (cv::waitKey(30) >= 0) break;
	}
}

#pragma endregion

#pragma region lab3

void lab3wejsciowka()
{
	cv::Mat img = cv::imread("pies.jpg", CV_LOAD_IMAGE_GRAYSCALE);

	int rows = img.rows;
	int cols = img.cols;

	for (int i = 0; i < rows; ++i) {
		for (int j = 0; j < cols; ++j) {
			if (((i / 100) % 2) < 1)
				img.at<uchar>(i, j) = 255 - img.at<uchar>(i, j);
			else
			{
				if (img.at<uchar>(i, j) > 100)
					img.at<uchar>(i, j) = 255;
				else
					img.at<uchar>(i, j) = 0;
			}

		}
	}

	cv::namedWindow("Pies");// Create a window for display.
	cv::imshow("Pies", img);
	cv::waitKey(0);
}

// different blur types 
void lab3zad1()
{
	cv::Mat img = cv::imread("lena_noise.bmp", CV_LOAD_IMAGE_GRAYSCALE);
	cv::Mat img_blur, img_gaussBlur, img_medianBlur, result;

	cv::blur(img, img_blur, cv::Size(3, 3));
	cv::GaussianBlur(img, img_gaussBlur, cv::Size(3, 3), 3, 3);
	cv::medianBlur(img, img_medianBlur, 3);

	std::vector<cv::Mat> matrices = { img, img_blur, img_gaussBlur, img_medianBlur };
	cv::hconcat(matrices, result);

	cv::hconcat(img, img_blur, img);
	cv::hconcat(img, img_gaussBlur, img);
	cv::hconcat(img, img_medianBlur, img);
	
	cv::namedWindow("baba");// Create a window for display.
	cv::imshow("baba", img);
	cv::waitKey(0);
}

void lab3zad2()
{
	cv::Mat img = cv::imread("morphology.png", CV_LOAD_IMAGE_GRAYSCALE);
	cv::Mat img_erode, img_dilate, result;


	cv::erode(img, img_erode, cv::Mat(), cv::Point(-1, -1), 3);
	cv::dilate(img, img_dilate, cv::Mat(), cv::Point(-1, -1), 3);

	cv::hconcat(img, img_erode, img);
	cv::hconcat(img, img_dilate, img);

	cv::namedWindow("litera");
	cv::imshow("litera", img);
	cv::waitKey(0);
}

void my_blur(cv::Mat &src, cv::Mat &dst)
{
	int rows = src.rows;
	int cols = src.cols;
	int temp = 0;

	for (int i = 0; i < rows-2; ++i) {
		for (int j = 0; j < cols-2; ++j) {
			cv::Rect myROI(i, j, i + 3, j + 3);
			cv::Mat window = src(myROI);
		}
	}
}

#pragma endregion

#pragma region lab4

void lab4zad1()
{
	image = cv::imread("pies.jpg");

	cv::namedWindow("window");// Create a window for display.

	cv::setMouseCallback("window", onMouse, 0);

	cv::imshow("window", image);
	cv::waitKey(0);
}

void lab4zad2()
{
	image = cv::imread("pies.jpg");

	cv::namedWindow("window");// Create a window for display.

	cv::imshow("window", image);
	cv::waitKey(0);
}

#pragma endregion

#pragma region lab5

void defineMasks()
{
	Px.create(cv::Size(3, 3), CV_8SC1);
	for (int i = 0; i < 3; i++)
	{
		Px.col(i).setTo(cv::Scalar(i - 1));
	}

	Py.create(cv::Size(3, 3), CV_8SC1);
	for (int i = 0; i < 3; i++)
	{
		Py.row(i).setTo(cv::Scalar(i - 1));
	}

	Sx.create(cv::Size(3, 3), CV_8SC1);
	for (int i = 0; i < 3; i++)
	{
		Sx.col(i).setTo(cv::Scalar(i - 1));
	}
	Sx.row()
}

void lab5zad1()
{
	defineMasks();
	image = cv::imread("obrazek.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	cv::namedWindow("window");
}

#pragma endregion

int main(int, char**) {
	defineMasks();

	int dummy_data[9] = { -1, 0, 1,
								-2, 0, 2,
								-1, 0, 1 };

	cv::Mat Sx = cv::Mat(3, 3, CV_16SC1, dummy_data);

	int dummy_data2[9] = { -1, -2, -1,
								 0,  0,  0,
								 1,  2,  1 };

	cv::Mat Sy = cv::Mat(3, 3, CV_16SC1, dummy_data2);

	std::cout << Sx << std::endl << Sy;

	cv::Mat filteredX, filteredY, filtered;
	cv::filter2D(obraz, filteredX, CV_32F, Px, cv::Point(-1, -1));
	cv::filter2D(obraz, filteredY, CV_32F, Py, cv::Point(-1, -1));

	filteredX.convertTo(filteredX, CV_8U);
	filteredX.convertTo(filteredY, CV_8U);


	int rows = filteredX.rows;
	int cols = filteredX.cols;

	for (int i = 0; i < rows; ++i) {
		for (int j = 0; j < cols; ++j) {
			std::cout << filteredX.at<uchar>(i, j);
		}
	}

	cv::imshow("window", filtered);
	cv::waitKey(0);

	return 0;
}



